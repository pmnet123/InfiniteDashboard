<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Infinite Dashboard with Rich Text</title>
  <style>
    /* ==================== BASE STYLES ==================== */
    html, body { 
      margin: 0; padding: 0; overflow: hidden; height: 100%; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #ffffff;
    }
    #canvas { 
      display: block; cursor: default; 
      background: #ffffff;
    }
    
    /* ==================== CONTEXT MENU ==================== */
    #context-menu { 
      position: absolute; 
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      display: none; z-index: 10;
      border-radius: 12px;
      overflow: hidden;
      min-width: 180px;
    }
    #context-menu ul { list-style: none; margin: 0; padding: 6px; }
    #context-menu li { 
      padding: 12px 16px; cursor: pointer; 
      border-radius: 8px; margin: 2px 0;
      font-weight: 500; font-size: 14px;
      color: #2d3748;
      transition: all 0.2s ease;
      position: relative;
    }
    #context-menu li:hover { 
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      transform: translateX(2px);
    }
    #context-menu li::before {
      content: '';
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: currentColor;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    #context-menu li:hover::before { opacity: 1; }
    
    /* ==================== TEXT EDITOR ==================== */
    .block-input { 
      position: absolute; 
      border: 2px solid rgba(102, 126, 234, 0.3);
      border-radius: 12px;
      overflow: auto;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      box-sizing: border-box; z-index: 100; 
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      outline: none; padding: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
    .block-input:focus {
      border-color: #667eea;
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.2);
    }
    
    /* ==================== TEXT FORMAT MENU ==================== */
    .text-format-menu { 
      position: absolute; 
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      display: none; z-index: 200;
      padding: 16px; border-radius: 16px;
      min-width: 280px;
    }
    .text-format-menu button { 
      margin: 4px; padding: 8px 12px; 
      border: 1px solid rgba(102, 126, 234, 0.2);
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      cursor: pointer; border-radius: 8px;
      font-weight: 600;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
    }
    .text-format-menu button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
    }
    .text-format-menu button:active { 
      transform: translateY(0);
    }
    .text-format-menu select { 
      margin: 4px; 
      padding: 8px 12px;
      border: 1px solid rgba(102, 126, 234, 0.2);
      border-radius: 8px;
      background: white;
      font-family: inherit;
      font-size: 14px;
      outline: none;
      transition: all 0.2s ease;
    }
    .text-format-menu select:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .text-format-menu input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }
    .text-format-menu input[type="color"]:hover {
      transform: scale(1.1);
    }
    .format-group { 
      margin: 8px 0; 
      padding: 8px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 8px;
    }
    .format-group label { 
      font-size: 12px; 
      color: #4a5568; 
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      display: block;
    }
    
    /* ==================== SCALE INDICATOR ==================== */
    #scale-indicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border-radius: 12px;
      padding: 12px 16px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      font-weight: 600;
      color: #2d3748;
      z-index: 50;
      min-width: 80px;
      text-align: center;
      transition: all 0.3s ease;
      user-select: none;
    }
    #scale-indicator:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    
    /* ==================== SEARCH BAR ==================== */
    #search-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border-radius: 16px;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 60;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      transition: all 0.3s ease;
      opacity: 0;
      visibility: hidden;
    }
    #search-container.visible {
      opacity: 1;
      visibility: visible;
    }
    #search-input {
      border: none;
      background: transparent;
      outline: none;
      font-size: 14px;
      color: #2d3748;
      width: 250px;
      padding: 4px 8px;
    }
    #search-input::placeholder {
      color: #a0aec0;
    }
    .search-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: none;
      color: white;
      border-radius: 8px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s ease;
      min-width: 32px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .search-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    .search-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    #search-counter {
      font-size: 12px;
      color: #4a5568;
      font-weight: 500;
      min-width: 60px;
      text-align: center;
    }
    #search-close {
      background: rgba(255, 0, 0, 0.1);
      color: #e53e3e;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.2s ease;
    }
    #search-close:hover {
      background: rgba(255, 0, 0, 0.2);
    }
    
    /* ==================== SCROLLBARS ==================== */
    .block-input::-webkit-scrollbar,
    .text-format-menu::-webkit-scrollbar {
      width: 6px;
    }
    .block-input::-webkit-scrollbar-track,
    .text-format-menu::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }
    .block-input::-webkit-scrollbar-thumb,
    .text-format-menu::-webkit-scrollbar-thumb {
      background: rgba(102, 126, 234, 0.5);
      border-radius: 3px;
    }
    .block-input::-webkit-scrollbar-thumb:hover,
    .text-format-menu::-webkit-scrollbar-thumb:hover {
      background: rgba(102, 126, 234, 0.7);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="context-menu"><ul></ul></div>
  <div id="scale-indicator">100%</div>
  <div id="search-container">
    <input type="text" id="search-input" placeholder="Search blocks...">
    <button class="search-btn" id="search-prev" title="Previous">◀</button>
    <div id="search-counter">0/0</div>
    <button class="search-btn" id="search-next" title="Next">▶</button>
    <div id="search-close">×</div>
  </div>
  <div id="text-format-menu" class="text-format-menu">
    <div class="format-group">
      <label>Font:</label>
      <select id="font-family">
        <option value="Arial">Arial</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Courier New">Courier New</option>
        <option value="Helvetica">Helvetica</option>
        <option value="Georgia">Georgia</option>
        <option value="Verdana">Verdana</option>
      </select>
      <select id="font-size">
        <option value="8">8px</option>
        <option value="10">10px</option>
        <option value="12">12px</option>
        <option value="14">14px</option>
        <option value="16">16px</option>
        <option value="18" selected>18px</option>
        <option value="20">20px</option>
        <option value="24">24px</option>
        <option value="28">28px</option>
        <option value="32">32px</option>
      </select>
    </div>
    <div class="format-group">
      <button id="bold-btn"><b>B</b></button>
      <button id="italic-btn"><i>I</i></button>
      <button id="underline-btn"><u>U</u></button>
      <input type="color" id="text-color" value="#000000" title="Text Color">
    </div>
  </div>
  
  <script>
    'use strict';
    
    /* ==================== GLOBAL VARIABLES ==================== */
    // Prevent right-click context menu
    document.addEventListener('contextmenu', e => e.preventDefault());
    
    // DOM Elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const contextMenu = document.getElementById('context-menu');
    const menuList = contextMenu.querySelector('ul');
    const textFormatMenu = document.getElementById('text-format-menu');
    const scaleIndicator = document.getElementById('scale-indicator');
    const searchContainer = document.getElementById('search-container');
    const searchInput = document.getElementById('search-input');
    const searchPrev = document.getElementById('search-prev');
    const searchNext = document.getElementById('search-next');
    const searchCounter = document.getElementById('search-counter');
    const searchClose = document.getElementById('search-close');

    // Canvas state
    let scale = 1, originX = 0, originY = 0;
    let isDragging = false, dragStart = { x:0, y:0 };
    let resizing = false, resizeItem = null, resizeDir = '', resizeStart = {};
    const minSize = 20, edgeThreshold = 10;
    
    // Application state
    let items = [], nextId = 1;
    let connecting = false, connectionStart = null;
    let deletingConnector = false, deleteConnectionStart = null;
    let selecting = false, selectedItem = null;
    let rightClickTarget = null;
    let backgroundColor = '#ffffff';
    
    // Text editing state
    let currentEditor = null;
    let textSelection = null;
    let isUsingFormatControls = false;
    
    // Search functionality state
    let searchResults = [];
    let currentSearchIndex = -1;
    let searchTerm = '';
    let highlightedBlocks = new Set();
    
    // Undo functionality state
    let undoStack = [];
    let maxUndoSteps = 10; // Limit undo history to prevent memory issues
    
    // Link click detection state
    let renderedLinks = []; // Store clickable link areas for hit detection

    /* ==================== INITIALIZATION ==================== */
    function initializeApp() {
      resizeCanvas();
      updateScaleIndicator();
      setupEventListeners();
      
      // Save initial state for undo functionality
      saveState('Initial state');
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }
    
    function setupEventListeners() {
      // Window events
      window.addEventListener('resize', resizeCanvas);
      
      // Search events
      searchInput.addEventListener('input', (e) => performSearch(e.target.value));
      searchNext.addEventListener('click', goToNextResult);
      searchPrev.addEventListener('click', goToPrevResult);
      searchClose.addEventListener('click', hideSearchBar);
      
      // Global keyboard shortcuts
      document.addEventListener('keydown', handleGlobalKeyboard);
      
      // Canvas events
      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('mouseleave', handleCanvasMouseUp);
      canvas.addEventListener('wheel', handleCanvasWheel);
      canvas.addEventListener('dblclick', handleCanvasDoubleClick);
      
      // Context menu events
      contextMenu.addEventListener('click', handleContextMenuClick);
      document.addEventListener('mousedown', handleDocumentMouseDown);
      
      // Text formatting events
      setupTextFormattingEvents();
      
      // Prevent search container from interfering with canvas
      searchContainer.addEventListener('mousedown', (e) => e.stopPropagation());
      searchContainer.addEventListener('wheel', (e) => e.stopPropagation());
    }

    /* ==================== UTILITY FUNCTIONS ==================== */
    function toWorld(cx, cy) { 
      return { x:(cx-originX)/scale, y:(cy-originY)/scale }; 
    }

    function isValidURL(string) {
      try {
        // Check for common URL patterns
        const urlPattern = /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/i;
        const wwwPattern = /^www\.[\da-z\.-]+\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/i;
        
        // If it starts with http/https, try URL constructor
        if (string.startsWith('http://') || string.startsWith('https://')) {
          new URL(string);
          return true;
        }
        
        // Check for www. pattern
        if (wwwPattern.test(string)) {
          return true;
        }
        
        // Check for domain.tld pattern
        if (urlPattern.test(string)) {
          return true;
        }
        
        return false;
      } catch (_) {
        return false;
      }
    }

    function makeURLClickable(url) {
      let finalURL = url;
      
      // Add protocol if missing
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        finalURL = 'https://' + url;
      }
      
      return finalURL;
    }

    function autoLinkText(text) {
      // URL pattern that matches common URL formats
      const urlPattern = /(https?:\/\/[^\s]+|www\.[^\s]+|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.([a-zA-Z]{2,})(\/[^\s]*)?)/gi;
      
      return text.replace(urlPattern, (match) => {
        if (isValidURL(match)) {
          const clickableURL = makeURLClickable(match);
          return `<a href="${clickableURL}" target="_blank" rel="noopener noreferrer" style="color: #0066cc; text-decoration: underline;">${match}</a>`;
        }
        return match;
      });
    }

    function updateScaleIndicator() {
      scaleIndicator.textContent = Math.round(scale * 100) + '%';
    }
    
    function updateBackgroundColor() {
      document.body.style.background = backgroundColor;
      canvas.style.background = backgroundColor;
      draw();
    }

    function getCenter(item) {
      return [item.x + item.w/2, item.y + item.h/2];
    }

    function adjustBrightness(color, percent) {
      const num = parseInt(color.replace("#",""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    function getContrastColor(bgColor) {
      const hex = bgColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.6)';
    }
    
    function getGridContrastColor(bgColor) {
      const hex = bgColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)';
    }
    
    function getConnectorContrastColor(bgColor) {
      const hex = bgColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      
      if (luminance > 0.5) {
        return {
          start: 'rgba(30, 40, 100, 0.9)',
          end: 'rgba(50, 20, 80, 0.9)',
          arrow: '#1e2864'
        };
      } else {
        return {
          start: 'rgba(150, 170, 255, 0.95)',
          end: 'rgba(180, 150, 255, 0.95)',
          arrow: '#96aaff'
        };
      }
    }

    /* ==================== SEARCH FUNCTIONALITY ==================== */
    function performSearch(term) {
      searchTerm = term.toLowerCase();
      searchResults = [];
      highlightedBlocks.clear();
      
      if (!searchTerm.trim()) {
        updateSearchUI();
        draw();
        return;
      }
      
      items.filter(item => item.type === 'rect').forEach(item => {
        const textContent = (item.text || '') + ' ' + (item.richText ? stripHTML(item.richText) : '');
        if (textContent.toLowerCase().includes(searchTerm)) {
          searchResults.push(item);
          highlightedBlocks.add(item.id);
        }
      });
      
      currentSearchIndex = searchResults.length > 0 ? 0 : -1;
      updateSearchUI();
      
      if (currentSearchIndex >= 0) {
        centerOnBlock(searchResults[currentSearchIndex]);
      }
      
      draw();
    }
    
    function stripHTML(html) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      return temp.textContent || temp.innerText || '';
    }
    
    function updateSearchUI() {
      const total = searchResults.length;
      const current = currentSearchIndex >= 0 ? currentSearchIndex + 1 : 0;
      searchCounter.textContent = `${current}/${total}`;
      
      searchPrev.disabled = total === 0 || currentSearchIndex <= 0;
      searchNext.disabled = total === 0 || currentSearchIndex >= total - 1;
    }
    
    function goToNextResult() {
      if (searchResults.length === 0) return;
      
      currentSearchIndex = (currentSearchIndex + 1) % searchResults.length;
      updateSearchUI();
      centerOnBlock(searchResults[currentSearchIndex]);
      draw();
    }
    
    function goToPrevResult() {
      if (searchResults.length === 0) return;
      
      currentSearchIndex = currentSearchIndex <= 0 ? searchResults.length - 1 : currentSearchIndex - 1;
      updateSearchUI();
      centerOnBlock(searchResults[currentSearchIndex]);
      draw();
    }
    
    function centerOnBlock(block) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      originX = centerX - (block.x + block.w / 2) * scale;
      originY = centerY - (block.y + block.h / 2) * scale;
    }
    
    function showSearchBar() {
      searchContainer.classList.add('visible');
      searchInput.focus();
    }
    
    function hideSearchBar() {
      searchContainer.classList.remove('visible');
      searchResults = [];
      highlightedBlocks.clear();
      currentSearchIndex = -1;
      searchTerm = '';
      searchInput.value = '';
      draw();
    }

    /* ==================== UNDO FUNCTIONALITY ==================== */
    function saveState(actionDescription) {
      // Create a deep copy of the current state
      const state = {
        items: JSON.parse(JSON.stringify(items)),
        nextId: nextId,
        originX: originX,
        originY: originY,
        scale: scale,
        backgroundColor: backgroundColor,
        description: actionDescription,
        timestamp: Date.now()
      };
      
      undoStack.push(state);
      
      // Limit undo stack size to prevent memory issues
      if (undoStack.length > maxUndoSteps) {
        undoStack.shift(); // Remove oldest entry
      }
      
      console.log(`State saved: ${actionDescription} (${undoStack.length} states in history)`);
    }

    function performUndo() {
      if (undoStack.length === 0) {
        console.log('No actions to undo');
        return;
      }
      
      const previousState = undoStack.pop();
      
      // Restore the previous state
      items = JSON.parse(JSON.stringify(previousState.items));
      nextId = previousState.nextId;
      originX = previousState.originX;
      originY = previousState.originY;
      scale = previousState.scale;
      backgroundColor = previousState.backgroundColor;
      
      // Update UI elements
      updateBackgroundColor();
      updateScaleIndicator();
      
      // Clear search results if any
      if (highlightedBlocks.size > 0) {
        hideSearchBar();
      }
      
      draw();
      
      console.log(`Undid action: ${previousState.description} (${undoStack.length} states remaining)`);
    }

    function clearUndoHistory() {
      undoStack = [];
      console.log('Undo history cleared');
    }

    /* ==================== EVENT HANDLERS ==================== */
    function handleGlobalKeyboard(e) {
      if (e.ctrlKey && e.key === 'f') {
        e.preventDefault();
        showSearchBar();
      } else if (e.key === 'Escape' && searchContainer.classList.contains('visible')) {
        e.preventDefault();
        hideSearchBar();
      } else if (searchContainer.classList.contains('visible') && e.key === 'Enter') {
        e.preventDefault();
        if (e.shiftKey) {
          goToPrevResult();
        } else {
          goToNextResult();
        }
      } else if (e.ctrlKey && e.key === 'z' && !currentEditor) {
        e.preventDefault();
        performUndo();
      }
    }

    function handleCanvasMouseDown(e) {
      if (e.button === 2) {
        const {x:mx,y:my} = toWorld(e.clientX, e.clientY);
        const hit = findItem(mx, my);
        showContextMenu(e.clientX, e.clientY, mx, my, hit);
        return;
      }
      
      const {x:mx,y:my} = toWorld(e.clientX, e.clientY);
      
      // Check for link clicks first
      const linkHit = findLinkAt(mx, my);
      if (linkHit && e.button === 0) {
        window.open(linkHit.url, '_blank', 'noopener,noreferrer');
        return;
      }
      
      if (connecting) {
        const hit = findItem(mx, my);
        if (hit) {
          if (!connectionStart) connectionStart = hit.id;
          else { 
            saveState('Add connector');
            items.push({ 
              id: nextId++, 
              type: 'connector', 
              from: connectionStart, 
              to: hit.id,
              hasArrows: true,
              isDashed: false
            }); 
            connecting = false; 
            draw(); 
          }
        }
        return;
      }
      
      if (deletingConnector) {
        const hit = findItem(mx, my);
        if (hit) {
          if (!deleteConnectionStart) {
            deleteConnectionStart = hit.id;
          } else {
            const connectorIndex = items.findIndex(item => 
              item.type === 'connector' && 
              ((item.from === deleteConnectionStart && item.to === hit.id) ||
               (item.from === hit.id && item.to === deleteConnectionStart))
            );
            if (connectorIndex !== -1) {
              saveState('Delete connector by selection');
              items.splice(connectorIndex, 1);
            }
            deletingConnector = false;
            deleteConnectionStart = null;
            draw();
          }
        }
        return;
      }
      
      const edge = findEdge(mx, my);
      if (edge) {
        resizing = true; 
        resizeItem = edge.item; 
        resizeDir = edge.dir;
        resizeStart = { x:mx, y:my, w:edge.item.w, h:edge.item.h };
        return;
      }
      
      const hit = findItem(mx, my);
      if (hit) {
        selectedItem = hit; 
        selecting = true;
        dragStart = { x:mx - hit.x, y:my - hit.y };
      } else {
        selecting = false; 
        isDragging = true;
        dragStart = { x:e.clientX - originX, y:e.clientY - originY };
      }
    }

    function handleCanvasMouseMove(e) {
      const {x:mx,y:my} = toWorld(e.clientX, e.clientY);
      
      if (resizing && resizeItem) {
        const dx = mx - resizeStart.x, dy = my - resizeStart.y;
        if (resizeDir.includes('e')) resizeItem.w = Math.max(minSize, resizeStart.w + dx);
        if (resizeDir.includes('s')) resizeItem.h = Math.max(minSize, resizeStart.h + dy);
        draw(); 
        return;
      }
      
      if (selecting && selectedItem) {
        selectedItem.x = mx - dragStart.x; 
        selectedItem.y = my - dragStart.y; 
        draw(); 
        return;
      }
      
      if (isDragging) {
        originX = e.clientX - dragStart.x; 
        originY = e.clientY - dragStart.y; 
        draw(); 
        return;
      }
      
      // Set cursor based on what's under the mouse
      const linkHit = findLinkAt(mx, my);
      if (linkHit) {
        canvas.style.cursor = 'pointer';
      } else {
        canvas.style.cursor = findEdge(mx, my) ? 'nwse-resize' : 'default';
      }
    }

    function handleCanvasMouseUp() { 
      isDragging = false; 
      selecting = false; 
      resizing = false; 
    }

    function handleCanvasWheel(e) {
      e.preventDefault(); 
      const delta = -e.deltaY * 0.001;
      const newScale = Math.min(Math.max(0.2, scale + delta), 5);
      const rect = canvas.getBoundingClientRect(); 
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      originX = cx - (cx-originX) * (newScale/scale);
      originY = cy - (cy-originY) * (newScale/scale);
      scale = newScale; 
      updateScaleIndicator();
      draw();
    }

    function handleCanvasDoubleClick(e) {
      const {x:mx,y:my} = toWorld(e.clientX, e.clientY);
      const hit = items.slice().reverse().find(it=>it.type==='rect'&&mx>=it.x&&mx<=it.x+it.w&&my>=it.y&&my<=it.y+it.h);
      if (!hit) return;
      
      createTextEditor(hit);
    }

    function handleContextMenuClick(e) {
      const li = e.target.closest('li'); 
      if (!li) return;
      
      const action = li.dataset.action;
      const target = rightClickTarget;
      const wx = parseFloat(contextMenu.dataset.x);
      const wy = parseFloat(contextMenu.dataset.y);
      hideContextMenu();

      executeContextAction(action, target, wx, wy);
      rightClickTarget = null;
    }

    function handleDocumentMouseDown(e) {
      if (e.button === 0 && !contextMenu.contains(e.target) && !textFormatMenu.contains(e.target)) {
        hideContextMenu();
        hideTextFormatMenu();
      }
    }

    /* ==================== CONTEXT MENU FUNCTIONALITY ==================== */
    function showContextMenu(px, py, wx, wy, hit) {
      menuList.innerHTML = '';
      
      if (hit) {
        rightClickTarget = hit;
        if (hit.type === 'connector') {
          ['Toggle Arrows','Toggle Dashed','Delete Connector','Save','Load'].forEach(text => {
            const li = document.createElement('li'); 
            li.textContent = text;
            li.dataset.action = text.toLowerCase().replace(/ /g,'-');
            menuList.appendChild(li);
          });
        } else {
          ['Change Color','Copy Block','Delete Block','Save','Load'].forEach(text => {
            const li = document.createElement('li'); 
            li.textContent = text;
            li.dataset.action = text.toLowerCase().replace(/ /g,'-');
            menuList.appendChild(li);
          });
        }
      } else {
        rightClickTarget = null;
        ['Save','Load','Add Colored Box','Add Connector','Delete Connector','Change Background Color','Search','Undo'].forEach(text => {
          const li = document.createElement('li'); 
          li.textContent = text;
          li.dataset.action = text.toLowerCase().replace(/ /g,'-');
          menuList.appendChild(li);
        });
      }
      
      contextMenu.style.left = px + 'px';
      contextMenu.style.top = py + 'px';
      contextMenu.style.display = 'block';
      contextMenu.dataset.x = wx;
      contextMenu.dataset.y = wy;
    }

    function hideContextMenu() { 
      contextMenu.style.display = 'none'; 
    }

    async function executeContextAction(action, target, wx, wy) {
      switch(action) {
        case 'save':
          await saveData();
          break;
        case 'load':
          loadData();
          break;
        case 'change-color':
          if (target) changeBlockColor(target);
          break;
        case 'copy-block':
          if (target) copyBlock(target);
          break;
        case 'delete-block':
          if (target) deleteBlock(target.id);
          break;
        case 'toggle-arrows':
          if (target && target.type === 'connector') toggleConnectorArrows(target);
          break;
        case 'toggle-dashed':
          if (target && target.type === 'connector') toggleConnectorDashed(target);
          break;
        case 'delete-connector':
          if (target && target.type === 'connector') deleteConnector(target);
          break;
        case 'add-colored-box':
          addRect(wx, wy);
          break;
        case 'add-connector':
          startConnector();
          break;
        case 'delete-connector':
          startDeleteConnector();
          break;
        case 'change-background-color':
          changeBackgroundColor();
          break;
        case 'search':
          showSearchBar();
          break;
        case 'undo':
          performUndo();
          break;
      }
    }

    /* ==================== BLOCK MANAGEMENT ==================== */
    function addRect(x, y) { 
      saveState('Add block');
      
      const modernColors = [
        '#0078d4', '#107c10', '#ffb900', '#d13438', 
        '#8764b8', '#00bcf2', '#038387', '#e3008c',
        '#881798', '#498205', '#ca5010', '#8e562e',
        '#525e75', '#567c73', '#486860', '#744da9'
      ];
      const randomColor = modernColors[Math.floor(Math.random() * modernColors.length)];
      
      items.push({ 
        id: nextId++, 
        type: 'rect', 
        x, y, w:150, h:100, 
        color: randomColor, 
        text: '', 
        richText: '' 
      }); 
      draw(); 
    }

    function copyBlock(originalBlock) {
      saveState('Copy block');
      
      const copiedBlock = {
        id: nextId++,
        type: 'rect',
        x: originalBlock.x,
        y: originalBlock.y + originalBlock.h + 20,
        w: originalBlock.w,
        h: originalBlock.h,
        color: originalBlock.color,
        text: originalBlock.text || '',
        richText: originalBlock.richText || ''
      };
      
      items.push(copiedBlock);
      draw();
    }
    
    function deleteBlock(blockId) {
      if (!confirm('Are you sure you want to delete this block and all its connections?')) {
        return;
      }
      
      saveState('Delete block');
      
      items = items.filter(item => 
        !(item.type === 'connector' && (item.from === blockId || item.to === blockId))
      );
      
      const blockIndex = items.findIndex(item => item.id === blockId);
      if (blockIndex !== -1) {
        items.splice(blockIndex, 1);
      }
      
      draw();
    }

    function changeBlockColor(target) {
      const input = document.createElement('input'); 
      input.type = 'color';
      input.value = /^#([0-9A-F]{3}){1,2}$/i.test(target.color) ? target.color : '#ffffff';
      input.style.position = 'fixed'; 
      input.style.left = contextMenu.style.left;
      input.style.top = contextMenu.style.top; 
      input.style.zIndex = 100;
      document.body.appendChild(input); 
      input.click();
      input.addEventListener('change', ev => { 
        saveState('Change block color');
        target.color = ev.target.value; 
        draw(); 
        input.remove(); 
      });
    }

    function changeBackgroundColor() {
      const input = document.createElement('input'); 
      input.type = 'color';
      input.value = backgroundColor;
      input.style.position = 'fixed'; 
      input.style.left = contextMenu.style.left;
      input.style.top = contextMenu.style.top; 
      input.style.zIndex = 100;
      document.body.appendChild(input); 
      input.click();
      input.addEventListener('change', ev => { 
        saveState('Change background color');
        backgroundColor = ev.target.value; 
        updateBackgroundColor();
        input.remove(); 
      });
    }

    /* ==================== CONNECTOR MANAGEMENT ==================== */
    function startConnector() { 
      connecting = true; 
      connectionStart = null; 
    }
    
    function startDeleteConnector() { 
      deletingConnector = true; 
      deleteConnectionStart = null; 
    }

    function toggleConnectorArrows(target) {
      saveState('Toggle connector arrows');
      target.hasArrows = (target.hasArrows !== false) ? false : true;
      draw();
    }

    function toggleConnectorDashed(target) {
      saveState('Toggle connector dashed style');
      target.isDashed = !target.isDashed;
      draw();
    }

    function deleteConnector(target) {
      if (!confirm('Are you sure you want to delete this connector?')) {
        return;
      }
      
      saveState('Delete connector');
      const connectorIndex = items.findIndex(item => item.id === target.id);
      if (connectorIndex !== -1) {
        items.splice(connectorIndex, 1);
        draw();
      }
    }

    /* ==================== ITEM FINDING ==================== */
    function findItem(x, y) { 
      const rect = items.slice().reverse().find(it=>it.type==='rect'&&x>=it.x&&x<=it.x+it.w&&y>=it.y&&y<=it.y+it.h);
      if (rect) return rect;
      
      const tolerance = 10 / scale;
      for (let i = items.length - 1; i >= 0; i--) {
        const connector = items[i];
        if (connector.type !== 'connector') continue;
        
        const fromItem = items.find(it => it.id === connector.from);
        const toItem = items.find(it => it.id === connector.to);
        if (!fromItem || !toItem) continue;
        
        const [ax, ay] = getCenter(fromItem);
        const [bx, by] = getCenter(toItem);
        
        const lineLength = Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2);
        const t = Math.max(0, Math.min(1, ((x - ax) * (bx - ax) + (y - ay) * (by - ay)) / (lineLength ** 2)));
        const projX = ax + t * (bx - ax);
        const projY = ay + t * (by - ay);
        const distance = Math.sqrt((x - projX) ** 2 + (y - projY) ** 2);
        
        if (distance <= tolerance) {
          return connector;
        }
      }
      
      return null; 
    }

    function findEdge(x, y) { 
      for(let i = items.length-1; i >= 0; i--) { 
        const it = items[i]; 
        if(it.type !== 'rect') continue; 
        const tol = edgeThreshold/scale; 
        const onE = Math.abs(x-(it.x+it.w)) < tol && y >= it.y && y <= it.y+it.h; 
        const onS = Math.abs(y-(it.y+it.h)) < tol && x >= it.x && x <= it.x+it.w; 
        if(onE && onS) return {item:it, dir:'se'}; 
        if(onE) return {item:it, dir:'e'}; 
        if(onS) return {item:it, dir:'s'}; 
      } 
      return null; 
    }

    function findLinkAt(x, y) {
      // Check if the point is within any rendered link bounds
      for (let link of renderedLinks) {
        if (x >= link.x && x <= link.x + link.width &&
            y >= link.y && y <= link.y + link.height) {
          return link;
        }
      }
      return null;
    }

    /* ==================== TEXT EDITING ==================== */
    function createTextEditor(hit) {
      const existing = document.querySelector('.block-input'); 
      if(existing) existing.remove();
      
      const editor = document.createElement('div'); 
      editor.className = 'block-input';
      editor.contentEditable = true;
      editor.style.left = (originX + hit.x * scale) + 'px'; 
      editor.style.top = (originY + hit.y * scale) + 'px';
      editor.style.width = (hit.w * scale) + 'px'; 
      editor.style.height = (hit.h * scale) + 'px';
      editor.style.backgroundColor = hit.color;
      editor.style.fontSize = (18 * scale) + 'px';
      editor.innerHTML = hit.richText || hit.text || '';
      
      // Auto-link any URLs that might be in existing text
      setTimeout(() => {
        autoLinkURLsInEditor(editor);
      }, 50);
      
      const spans = editor.querySelectorAll('span[style*="font-size"]');
      spans.forEach(span => {
        const currentSize = parseInt(span.style.fontSize);
        if (currentSize) {
          span.style.fontSize = (currentSize * scale) + 'px';
        }
      });
      
      editor.addEventListener('wheel', ev => ev.stopPropagation());
      editor.addEventListener('mouseup', handleTextSelection);
      editor.addEventListener('keyup', handleTextSelection);
      editor.addEventListener('contextmenu', handleTextContextMenu);
      editor.addEventListener('blur', (e) => saveTextEditor(e, hit, editor));
      
      // Handle URL auto-linking on paste and input
      editor.addEventListener('paste', handleTextPaste);
      editor.addEventListener('input', handleTextInput);
      
      // Handle link clicks during editing
      editor.addEventListener('click', handleEditorClick);
      
      document.body.appendChild(editor); 
      editor.focus();
      currentEditor = editor;
    }

    function handleTextSelection() {
      const selection = window.getSelection();
      if (selection.rangeCount > 0 && !selection.isCollapsed) {
        textSelection = selection.getRangeAt(0).cloneRange();
      }
    }

    function handleTextContextMenu(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      const selection = window.getSelection();
      if (selection.rangeCount > 0 && !selection.isCollapsed) {
        textSelection = selection.getRangeAt(0).cloneRange();
        showTextFormatMenu(ev.clientX, ev.clientY);
      }
    }

    function saveTextEditor(e, hit, editor) {
      setTimeout(() => {
        if (!isUsingFormatControls && currentEditor === editor) {
          const spans = editor.querySelectorAll('span[style]');
          spans.forEach(span => {
            const currentSize = parseInt(span.style.fontSize);
            if (currentSize) {
              const originalSize = Math.round(currentSize / scale);
              span.style.fontSize = originalSize + 'px';
            }
          });
          
          // Check if content actually changed before saving state
          const newRichText = editor.innerHTML;
          const newText = editor.textContent || editor.innerText;
          
          if (newRichText !== (hit.richText || '') || newText !== (hit.text || '')) {
            saveState('Edit text content');
          }
          
          hit.richText = newRichText;
          hit.text = newText;
          editor.remove(); 
          currentEditor = null;
          hideTextFormatMenu();
          draw(); 
        }
      }, 150);
    }

    function handleTextPaste(e) {
      // Let the paste happen first, then auto-link URLs
      setTimeout(() => {
        autoLinkURLsInEditor(e.target);
      }, 10);
    }

    function handleTextInput(e) {
      // Debounce auto-linking to avoid performance issues
      clearTimeout(e.target.autoLinkTimer);
      e.target.autoLinkTimer = setTimeout(() => {
        autoLinkURLsInEditor(e.target);
      }, 500);
    }

    function autoLinkURLsInEditor(editor) {
      if (!editor) return;
      
      // Save current cursor position
      const selection = window.getSelection();
      let range = null;
      let offset = 0;
      
      if (selection.rangeCount > 0) {
        range = selection.getRangeAt(0);
        offset = range.startOffset;
      }
      
      // Get all text nodes that might contain URLs
      const walker = document.createTreeWalker(
        editor,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        textNodes.push(node);
      }
      
      // Process text nodes and replace URLs
      let cursorAdjustment = 0;
      textNodes.forEach(textNode => {
        const originalText = textNode.textContent;
        const linkedText = autoLinkText(originalText);
        
        if (linkedText !== originalText) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = linkedText;
          
          // Replace the text node with the new content
          const fragment = document.createDocumentFragment();
          while (tempDiv.firstChild) {
            fragment.appendChild(tempDiv.firstChild);
          }
          
          const parent = textNode.parentNode;
          parent.insertBefore(fragment, textNode);
          parent.removeChild(textNode);
          
          // Adjust cursor position if this was the node being edited
          if (range && range.startContainer === textNode) {
            cursorAdjustment = linkedText.length - originalText.length;
          }
        }
      });
      
      // Restore cursor position if possible
      if (range && selection.rangeCount > 0) {
        try {
          const newRange = document.createRange();
          const walker = document.createTreeWalker(
            editor,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );
          
          let textNode = walker.nextNode();
          if (textNode && offset <= textNode.textContent.length) {
            newRange.setStart(textNode, Math.min(offset, textNode.textContent.length));
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
          }
        } catch (e) {
          // If cursor restoration fails, just place it at the end
          editor.focus();
        }
      }
    }

    function handleEditorClick(e) {
      // Check if the click target is a link or inside a link
      let target = e.target;
      let linkElement = null;
      
      // Walk up the DOM tree to find a link
      while (target && target !== e.currentTarget) {
        if (target.tagName === 'A' && target.href) {
          linkElement = target;
          break;
        }
        target = target.parentElement;
      }
      
      if (linkElement) {
        // Check if this is a Ctrl+click or if user specifically wants to open the link
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          e.stopPropagation();
          window.open(linkElement.href, '_blank', 'noopener,noreferrer');
        } else {
          // For regular clicks, show a tooltip or hint
          showLinkHint(linkElement, e);
        }
      }
    }

    function showLinkHint(linkElement, event) {
      // Remove any existing hint
      const existingHint = document.getElementById('link-hint');
      if (existingHint) {
        existingHint.remove();
      }
      
      // Create a temporary tooltip
      const hint = document.createElement('div');
      hint.id = 'link-hint';
      hint.innerHTML = `
        <div style="
          position: fixed;
          background: rgba(0, 0, 0, 0.9);
          color: white;
          padding: 8px 12px;
          border-radius: 6px;
          font-size: 12px;
          z-index: 10000;
          pointer-events: none;
          white-space: nowrap;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
          Hold Ctrl and click to open: ${linkElement.textContent}
        </div>
      `;
      
      // Position the hint near the mouse cursor
      const hintDiv = hint.firstElementChild;
      hintDiv.style.left = (event.clientX + 10) + 'px';
      hintDiv.style.top = (event.clientY - 40) + 'px';
      
      document.body.appendChild(hint);
      
      // Remove hint after 3 seconds
      setTimeout(() => {
        if (hint && hint.parentNode) {
          hint.remove();
        }
      }, 3000);
    }

    /* ==================== TEXT FORMATTING ==================== */
    function setupTextFormattingEvents() {
      document.getElementById('bold-btn').addEventListener('mousedown', (e) => {
        isUsingFormatControls = true;
        e.preventDefault();
        e.stopPropagation();
      });
      document.getElementById('bold-btn').addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        applyTextFormat('bold');
        setTimeout(() => { isUsingFormatControls = false; }, 200);
      });

      document.getElementById('italic-btn').addEventListener('mousedown', (e) => {
        isUsingFormatControls = true;
        e.preventDefault();
        e.stopPropagation();
      });
      document.getElementById('italic-btn').addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        applyTextFormat('italic');
        setTimeout(() => { isUsingFormatControls = false; }, 200);
      });

      document.getElementById('underline-btn').addEventListener('mousedown', (e) => {
        isUsingFormatControls = true;
        e.preventDefault();
        e.stopPropagation();
      });
      document.getElementById('underline-btn').addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        applyTextFormat('underline');
        setTimeout(() => { isUsingFormatControls = false; }, 200);
      });

      document.getElementById('text-color').addEventListener('mousedown', () => {
        isUsingFormatControls = true;
      });
      document.getElementById('text-color').addEventListener('input', handleColorChange);

      document.getElementById('font-family').addEventListener('mousedown', () => {
        isUsingFormatControls = true;
      });
      document.getElementById('font-family').addEventListener('change', handleFontFamilyChange);

      document.getElementById('font-size').addEventListener('mousedown', () => {
        isUsingFormatControls = true;
      });
      document.getElementById('font-size').addEventListener('change', handleFontSizeChange);

      textFormatMenu.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON') {
          e.preventDefault();
          e.stopPropagation();
        }
      });

      document.addEventListener('mousedown', (e) => {
        if (!textFormatMenu.contains(e.target) && e.target !== currentEditor) {
          hideTextFormatMenu();
        }
      });
    }

    function showTextFormatMenu(x, y) {
      textFormatMenu.style.left = x + 'px';
      textFormatMenu.style.top = y + 'px';
      textFormatMenu.style.display = 'block';
    }

    function hideTextFormatMenu() { 
      textFormatMenu.style.display = 'none'; 
    }

    function applyTextFormat(command, value = null) {
      if (!currentEditor) return;
      
      if (textSelection) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(textSelection);
      }
      
      currentEditor.focus();
      
      if (command === 'foreColor' || command === 'fontSize') {
        document.execCommand('styleWithCSS', false, true);
      }
      
      document.execCommand(command, false, value);
      
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        textSelection = selection.getRangeAt(0).cloneRange();
      }
    }

    function handleColorChange(e) {
      if (currentEditor && textSelection) {
        setTimeout(() => {
          currentEditor.focus();
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(textSelection);
          document.execCommand('styleWithCSS', false, true);
          document.execCommand('foreColor', false, e.target.value);
          if (selection.rangeCount > 0) {
            textSelection = selection.getRangeAt(0).cloneRange();
          }
          setTimeout(() => { isUsingFormatControls = false; }, 200);
        }, 10);
      }
    }

    function handleFontFamilyChange(e) {
      if (currentEditor && textSelection) {
        setTimeout(() => {
          currentEditor.focus();
          
          const selection = window.getSelection();
          if (selection.rangeCount === 0) {
            selection.removeAllRanges();
            selection.addRange(textSelection);
          }
          
          const selectedText = selection.toString();
          const fontFamily = e.target.value;
          
          if (selectedText && selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.style.fontFamily = fontFamily;
            
            try {
              const contents = range.extractContents();
              const spanElements = contents.querySelectorAll('span[style*="font-family"]');
              spanElements.forEach(innerSpan => {
                innerSpan.style.fontFamily = fontFamily;
              });
              
              span.appendChild(contents);
              range.insertNode(span);
              
              const newRange = document.createRange();
              newRange.selectNodeContents(span);
              selection.removeAllRanges();
              selection.addRange(newRange);
              textSelection = newRange.cloneRange();
            } catch (error) {
              console.error('Error applying font family:', error);
            }
          }
          
          setTimeout(() => { isUsingFormatControls = false; }, 200);
        }, 10);
      }
    }

    function handleFontSizeChange(e) {
      if (currentEditor && textSelection) {
        setTimeout(() => {
          currentEditor.focus();
          
          const selection = window.getSelection();
          if (selection.rangeCount === 0) {
            selection.removeAllRanges();
            selection.addRange(textSelection);
          }
          
          const selectedText = selection.toString();
          const fontSize = parseInt(e.target.value);
          
          if (selectedText && selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.style.fontSize = fontSize + 'px';
            
            try {
              const contents = range.extractContents();
              span.appendChild(contents);
              range.insertNode(span);
              
              const newRange = document.createRange();
              newRange.selectNodeContents(span);
              selection.removeAllRanges();
              selection.addRange(newRange);
              textSelection = newRange.cloneRange();
            } catch (error) {
              console.error('Error applying font size:', error);
            }
          }
          
          setTimeout(() => { isUsingFormatControls = false; }, 200);
        }, 10);
      }
    }

    /* ==================== DATA PERSISTENCE ==================== */
    async function encryptData(data, password) {
      try {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(data);
        const passwordBuffer = encoder.encode(password);
        
        const keyMaterial = await crypto.subtle.importKey(
          'raw',
          passwordBuffer,
          { name: 'PBKDF2' },
          false,
          ['deriveKey']
        );
        
        const salt = crypto.getRandomValues(new Uint8Array(16));
        
        const key = await crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
          },
          keyMaterial,
          { name: 'AES-GCM', length: 256 },
          false,
          ['encrypt']
        );
        
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        const encryptedBuffer = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          key,
          dataBuffer
        );
        
        const combinedBuffer = new Uint8Array(salt.length + iv.length + encryptedBuffer.byteLength);
        combinedBuffer.set(salt, 0);
        combinedBuffer.set(iv, salt.length);
        combinedBuffer.set(new Uint8Array(encryptedBuffer), salt.length + iv.length);
        
        const base64Data = btoa(String.fromCharCode(...combinedBuffer));
        return 'ENCRYPTED:' + base64Data;
      } catch (err) {
        console.error('Encryption error:', err);
        throw new Error('Encryption failed');
      }
    }

    async function decryptData(encryptedData, password) {
      try {
        const base64Data = encryptedData.replace('ENCRYPTED:', '');
        const combinedBuffer = new Uint8Array(atob(base64Data).split('').map(c => c.charCodeAt(0)));
        
        const salt = combinedBuffer.slice(0, 16);
        const iv = combinedBuffer.slice(16, 28);
        const encryptedBuffer = combinedBuffer.slice(28);
        
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        const passwordBuffer = encoder.encode(password);
        
        const keyMaterial = await crypto.subtle.importKey(
          'raw',
          passwordBuffer,
          { name: 'PBKDF2' },
          false,
          ['deriveKey']
        );
        
        const key = await crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
          },
          keyMaterial,
          { name: 'AES-GCM', length: 256 },
          false,
          ['decrypt']
        );
        
        const decryptedBuffer = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: iv },
          key,
          encryptedBuffer
        );
        
        return decoder.decode(decryptedBuffer);
      } catch (err) {
        console.error('Decryption error:', err);
        throw new Error('Decryption failed');
      }
    }

    async function saveData() {
      try {
        if (!('showSaveFilePicker' in window)) {
          alert('File picker not supported in this browser. Please use Chrome, Edge, or Safari.');
          return;
        }

        const password = prompt('Enter password for encryption (leave blank for no encryption):');
        if (password === null) {
          return;
        }
        
        const data = JSON.stringify({ items, originX, originY, scale, backgroundColor });
        
        let fileHandle;
        try {
          fileHandle = await window.showSaveFilePicker({
            suggestedName: 'dashboard.json',
            types: [{
              description: 'JSON files',
              accept: { 'application/json': ['.json'] }
            }]
          });
        } catch (err) {
          if (err.name === 'AbortError') {
            return;
          }
          throw new Error('File picker failed: ' + err.message);
        }
        
        let finalData = data;
        let isEncrypted = false;
        if (password && password.trim()) {
          finalData = await encryptData(data, password.trim());
          isEncrypted = true;
        }
        
        const writable = await fileHandle.createWritable();
        await writable.write(finalData);
        await writable.close();
        console.log(`File saved successfully${isEncrypted ? ' (encrypted)' : ' (unencrypted)'}`);
        
      } catch (err) {
        console.error('Save operation failed:', err);
        alert('Save failed: ' + err.message);
      }
    }

    function loadData() {
      const input = document.createElement('input');
      input.type = 'file'; 
      input.accept = 'application/json';
      input.style.display = 'none'; 
      document.body.appendChild(input);
      
      input.onchange = async evt => {
        const file = input.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async evt => {
          try {
            const fileContent = evt.target.result;
            let obj;
            
            if (fileContent.startsWith('ENCRYPTED:')) {
              const password = prompt('Enter password to decrypt the file:');
              if (!password) {
                alert('Password required to decrypt file.');
                return;
              }
              try {
                const decryptedData = await decryptData(fileContent, password.trim());
                obj = JSON.parse(decryptedData);
              } catch (decryptErr) {
                console.error('Decryption failed:', decryptErr);
                alert('Decryption failed. Wrong password or corrupted file.');
                return;
              }
            } else {
              obj = JSON.parse(fileContent);
            }
            
            items = obj.items || [];
            originX = obj.originX || 0;
            originY = obj.originY || 0;
            scale = obj.scale || 1;
            backgroundColor = obj.backgroundColor || '#ffffff';
            updateBackgroundColor();
            updateScaleIndicator();
            nextId = items.reduce((max, i) => Math.max(max, i.id), 0) + 1;
            
            // Clear undo history when loading a file
            clearUndoHistory();
            
            draw();
            console.log('File loaded successfully');
          } catch (err) {
            console.error('Invalid file:', err);
            alert('Invalid file format.');
          }
        };
        reader.readAsText(file);
        input.remove();
      };
      input.click();
    }

    /* ==================== RENDERING ==================== */
    function drawGrid() { 
      const grid = 100; 
      const w = canvas.width / scale, h = canvas.height / scale; 
      const sx = -originX / scale, sy = -originY / scale; 
      
      ctx.beginPath(); 
      ctx.strokeStyle = getGridContrastColor(backgroundColor); 
      ctx.lineWidth = 1 / scale; 
      for(let x = Math.floor(sx / grid) * grid; x < sx + w; x += grid) { 
        ctx.moveTo(x, sy); 
        ctx.lineTo(x, sy + h); 
      } 
      for(let y = Math.floor(sy / grid) * grid; y < sy + h; y += grid) { 
        ctx.moveTo(sx, y); 
        ctx.lineTo(sx + w, y); 
      } 
      ctx.stroke(); 
    }

    function renderTextInBlock(item) {
      if (!item.richText && !item.text) return;
      
      ctx.save();
      ctx.beginPath();
      ctx.rect(item.x, item.y, item.w, item.h);
      ctx.clip();
      
      if (item.richText) {
        renderRichText(item.richText, item.x + 2/scale, item.y + 2/scale, item.w - 4/scale, item.h - 4/scale);
      } else {
        ctx.fillStyle = '#000';
        ctx.font = `${18/scale}px Arial`;
        const lines = item.text.split('\n');
        const lineHeight = 21/scale;
        lines.forEach((line, idx) => {
          ctx.fillText(line, item.x + 2/scale, item.y + 2/scale + (idx + 1) * lineHeight);
        });
      }
      
      ctx.restore();
    }

    function renderRichText(html, x, y, maxWidth, maxHeight) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      let currentY = y;
      
      function walkNodes(node, inheritedStyle = {}) {
        if (currentY > y + maxHeight) return;
        
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          if (text.trim()) {
            const style = { ...inheritedStyle };
            let parent = node.parentElement;
            
            while (parent && parent !== tempDiv) {
              if (parent.tagName === 'B' || parent.tagName === 'STRONG') style.bold = true;
              if (parent.tagName === 'I' || parent.tagName === 'EM') style.italic = true;
              if (parent.tagName === 'U') style.underline = true;
              if (parent.tagName === 'A') {
                style.isLink = true;
                style.linkURL = parent.href;
                style.color = parent.style.color || '#0066cc';
                style.underline = true;
              }
              if (parent.style.color) style.color = parent.style.color;
              if (parent.style.fontSize) style.fontSize = parent.style.fontSize;
              if (parent.style.fontFamily) {
                let fontFamily = parent.style.fontFamily.replace(/['"]/g, '');
                fontFamily = fontFamily.split(',')[0].trim();
                style.fontFamily = fontFamily;
              }
              parent = parent.parentElement;
            }
            
            const baseFontSize = 18;
            const storedFontSize = style.fontSize ? parseInt(style.fontSize) : baseFontSize;
            const actualFontSize = storedFontSize / scale;
            const fontFamily = style.fontFamily || 'Arial';
            const fontWeight = style.bold ? 'bold' : 'normal';
            const fontStyle = style.italic ? 'italic' : 'normal';
            
            const dynamicLineHeight = actualFontSize * 1.4;
            
            ctx.font = `${fontStyle} ${fontWeight} ${actualFontSize}px "${fontFamily}"`;
            ctx.fillStyle = style.color || '#000';
            
            const words = text.split(/(\s+)/);
            let currentLine = '';
            let currentX = x;
            let maxLineHeight = actualFontSize;
            
            for (let word of words) {
              if (word.match(/^\s+$/)) {
                currentLine += word;
                continue;
              }
              
              const testLine = currentLine + word;
              const metrics = ctx.measureText(testLine);
              
              if (metrics.width > maxWidth && currentLine.trim()) {
                const lineWidth = ctx.measureText(currentLine).width;
                ctx.fillText(currentLine, currentX, currentY + maxLineHeight);
                
                // Store link bounds if this is a link
                if (style.isLink && style.linkURL) {
                  renderedLinks.push({
                    x: currentX,
                    y: currentY,
                    width: lineWidth,
                    height: maxLineHeight,
                    url: style.linkURL
                  });
                }
                
                if (style.underline) {
                  ctx.beginPath();
                  ctx.moveTo(currentX, currentY + maxLineHeight + 2);
                  ctx.lineTo(currentX + lineWidth, currentY + maxLineHeight + 2);
                  ctx.strokeStyle = style.color || '#000';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                }
                currentLine = word;
                currentY += dynamicLineHeight;
                currentX = x;
                maxLineHeight = actualFontSize;
                if (currentY > y + maxHeight) break;
              } else {
                currentLine = testLine;
                maxLineHeight = Math.max(maxLineHeight, actualFontSize);
              }
            }
            
            if (currentLine.trim() && currentY <= y + maxHeight) {
              const lineWidth = ctx.measureText(currentLine).width;
              ctx.fillText(currentLine, currentX, currentY + maxLineHeight);
              
              // Store link bounds if this is a link
              if (style.isLink && style.linkURL) {
                renderedLinks.push({
                  x: currentX,
                  y: currentY,
                  width: lineWidth,
                  height: maxLineHeight,
                  url: style.linkURL
                });
              }
              
              if (style.underline) {
                ctx.beginPath();
                ctx.moveTo(currentX, currentY + maxLineHeight + 2);
                ctx.lineTo(currentX + lineWidth, currentY + maxLineHeight + 2);
                ctx.strokeStyle = style.color || '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
              }
              if (currentLine.trim()) {
                currentY += dynamicLineHeight;
              }
            }
          }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const style = { ...inheritedStyle };
          
          if (node.tagName === 'BR') {
            const elementFontSize = style.fontSize ? parseInt(style.fontSize) : 12;
            currentY += elementFontSize * 1.4;
          } else if (node.tagName === 'DIV' && node.previousSibling) {
            const elementFontSize = style.fontSize ? parseInt(style.fontSize) : 12;
            currentY += elementFontSize * 0.6;
          }
          
          for (let child of node.childNodes) {
            walkNodes(child, style);
          }
        }
      }
      
      walkNodes(tempDiv);
    }
    
    function draw() { 
      ctx.setTransform(1,0,0,1,0,0); 
      ctx.clearRect(0,0,canvas.width,canvas.height); 
      ctx.translate(originX,originY); 
      ctx.scale(scale,scale); 
      
      // Clear link bounds for hit detection
      renderedLinks = [];
      
      drawGrid(); 
      
      // Draw connectors
      items.filter(i=>i.type==='connector').forEach(c=>{ 
        const a=items.find(i=>i.id===c.from),b=items.find(i=>i.id===c.to); 
        if(a&&b){ 
          const[ax,ay]=getCenter(a),[bx,by]=getCenter(b); 
          
          const connectorColors = getConnectorContrastColor(backgroundColor);
          
          const gradient = ctx.createLinearGradient(ax, ay, bx, by);
          gradient.addColorStop(0, connectorColors.start);
          gradient.addColorStop(1, connectorColors.end);
          
          ctx.beginPath(); 
          ctx.moveTo(ax,ay); 
          ctx.lineTo(bx,by); 
          ctx.lineWidth=2/scale; 
          ctx.strokeStyle=gradient; 
          ctx.lineCap = 'round';
          
          if (c.isDashed) {
            ctx.setLineDash([8/scale, 6/scale]);
          } else {
            ctx.setLineDash([]);
          }
          
          ctx.stroke(); 
          ctx.setLineDash([]);
          
          if (c.hasArrows !== false) {
            const angle = Math.atan2(by - ay, bx - ax);
            const arrowLength = 12 / scale;
            const arrowAngle = Math.PI / 6;
            
            for(let i = 1; i <= 2; i++) {
              const t = i / 3;
              const arrowX = ax + (bx - ax) * t;
              const arrowY = ay + (by - ay) * t;
              
              ctx.beginPath();
              ctx.moveTo(arrowX, arrowY);
              ctx.lineTo(
                arrowX - arrowLength * Math.cos(angle - arrowAngle),
                arrowY - arrowLength * Math.sin(angle - arrowAngle)
              );
              ctx.moveTo(arrowX, arrowY);
              ctx.lineTo(
                arrowX - arrowLength * Math.cos(angle + arrowAngle),
                arrowY - arrowLength * Math.sin(angle + arrowAngle)
              );
              ctx.lineWidth = 2 / scale;
              ctx.strokeStyle = connectorColors.arrow;
              ctx.stroke();
            }
          }
        } 
      }); 
      
      // Draw blocks
      items.filter(i=>i.type==='rect').forEach(it=>{ 
        const radius = 8 / scale;
        
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
        ctx.shadowBlur = 8 / scale;
        ctx.shadowOffsetX = 2 / scale;
        ctx.shadowOffsetY = 2 / scale;
        
        ctx.beginPath();
        ctx.roundRect(it.x, it.y, it.w, it.h, radius);
        
        ctx.fillStyle = it.color;
        ctx.fill();
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        ctx.strokeStyle = getContrastColor(backgroundColor); 
        ctx.lineWidth = 1.5 / scale; 
        ctx.stroke();
        
        // Highlight search results
        if (highlightedBlocks.has(it.id)) {
          const isCurrentResult = searchResults[currentSearchIndex] && searchResults[currentSearchIndex].id === it.id;
          
          ctx.beginPath();
          ctx.roundRect(it.x - 4/scale, it.y - 4/scale, it.w + 8/scale, it.h + 8/scale, (radius + 4/scale));
          ctx.strokeStyle = isCurrentResult ? '#ff6b35' : '#4299e1';
          ctx.lineWidth = (isCurrentResult ? 3 : 2) / scale;
          ctx.stroke();
          
          if (isCurrentResult) {
            const pulseAlpha = 0.3 + 0.2 * Math.sin(Date.now() / 300);
            ctx.beginPath();
            ctx.roundRect(it.x - 2/scale, it.y - 2/scale, it.w + 4/scale, it.h + 4/scale, (radius + 2/scale));
            ctx.fillStyle = `rgba(255, 107, 53, ${pulseAlpha})`;
            ctx.fill();
          }
        }
        
        ctx.restore();
        
        renderTextInBlock(it);
      }); 
      
      // Continue animation for search highlights
      if (highlightedBlocks.size > 0 && currentSearchIndex >= 0) {
        requestAnimationFrame(draw);
      }
    }

    /* ==================== APPLICATION START ==================== */
    initializeApp();
  </script>
</body>
</html>